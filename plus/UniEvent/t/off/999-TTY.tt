use strict;
use warnings;
use lib 't'; use PETest;
use UniEvent::Error;
use UniEvent::TTY qw/:const/;
use Test::More;

my $tty_out, my $tty_in;

sub check {
    return (-t STDIN and -t STDERR);
}

sub check_fun {
    return eval {
        open(\*STDERR, '>', '/dev/tty');
        open(\*STDIN, '<', '/dev/tty');
        1
    };
}

sub setup {
    my $ok_fun = $_[0];
    $ok_fun->(eval { $tty_out ||= UniEvent::TTY->new(\*STDERR); 1 }, 'Opening tty for writing');
    $ok_fun->(eval { $tty_in ||= UniEvent::TTY->new(\*STDIN, 1); 1 }, 'Opening tty for reading');
}

sub curtain {
    setup(sub {});
    logo() if check_fun();
}

unless (check) {
    curtain();
    plan skip_all => 'Not running TTY stdin, stderr';
    done_testing();
}

setup(\&ok);

is($tty_out->type, UniEvent::Handle::HTYPE_TTY, "new tty object type");
is($tty_in->type, UniEvent::Handle::HTYPE_TTY, "new tty object type, readable");

ok(eval {$tty_out->set_mode(UniEvent::TTY::MODE_NORMAL); 1}, "Set normal mode");
ok(eval {$tty_out->set_mode(UniEvent::TTY::MODE_IO); 1}, "Set IO mode");
ok(eval {$tty_in->set_mode(UniEvent::TTY::MODE_RAW); 1}, "Set raw mode");
ok(eval {UniEvent::TTY::reset_mode(); 1}, "reset_mode()");
my ($w, $h) = $tty_out->get_winsize();
diag "$w x $h";
ok(is_nat($w), "Term width is natural");
ok(is_nat($h), "Term height is natural");
ok($w > $h, "On normal terminals, width is greater than height");

sub is_nat {
    return (!!($_[0] + 0) and $_[0] eq int $_[0] and $_[0] >= 1);
}

sub logo {
    local $/;
    open(my $fh, '<', 'misc/panda.txt');
    my $contents = <$fh>;
    $tty_out->write("\n".$contents);
}

curtain();
done_testing();
